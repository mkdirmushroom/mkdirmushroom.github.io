<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F13%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android RecyclerView的使用解析（完结篇）]]></title>
      <url>%2F2016%2F10%2F19%2Fandroid_recycle_view_test_end%2F</url>
      <content type="text"><![CDATA[前言在前面两篇文章（Android RecyclerView的使用解析（一）、Android RecyclerView的使用解析（二））中，我们主要对RecyclerView作了简单的介绍并实现了它不同的布局效果，在本文中，我将对RecyclerView的动画机制和点击事件进行讲解。 ItemAnimator说到RecyclerView的动画机制，那我们就不得不提ItemAnimator这个类了，我们就是依靠它来实现item的动画效果的。这个类仍然是个抽象类，不过Google给我们提供了一些实现类，我们也可以自定义它的实现类以显示更加炫酷的效果。网上有很多讲解该类的文章，这里我就不多作分析了。 给item设置添加、删除动画 首先我们需要在菜单栏添加两个实现增加和删除item的按钮,打开menu文件夹下的布局文件，添加两个item项:12345678&lt;item android:id="@+id/action_add" android:title="ADD" android:orderInCategory="100" app:showAsAction="ifRoom" /&gt; &lt;item android:id="@+id/action_remove" android:title="REMOVE" android:orderInCategory="100" app:showAsAction="ifRoom" /&gt; 接着在TestAdapter中添加两个增加和删除item的方法：123456789public void addData(int pos) &#123; mDataset.add (pos, "Insert one"); notifyItemInserted (pos); &#125; public void removeData(int pos) &#123; mDataset.remove (pos); notifyItemRemoved (pos); &#125; 然后在MainActivity的Oncreate方法中给RecyclerView设置一个默认的动画效果:1mRecyclerView.setItemAnimator (new DefaultItemAnimator ()); 最后在onOptionsItemSelected方法中增加两个按钮的id：123456case R.id.action_add: mAdapter.addData (1); break; case R.id.action_remove: mAdapter.removeData (1); break; 由于我们给瀑布流的布局设置了不同的activity，所以还需将以上代码添加到StaggeredGridActivity和StagggeredAdapter。 运行效果如下： 额。。。虽然我们实现了添加和删除动画，但是每次都通过点击菜单选项来操作好像很繁琐耶，我们来优化一下呗。 我们可以给我们的demo增加一个ActionBar或ToolBar并把ADD和REMOVE按钮放在其上，为了方便，我这里使用的是ActionBar。修改代码，让MainActivty和StaggeredGridActivity继承自ActionBarActivity，接着修改values/styles.xml，将Theme指定为Theme.AppCompat.Light.DarkActionBar，代码如下：123456789&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;!--&lt;item name="android:listDivider"&gt;@drawable/my_divider&lt;/item&gt;--&gt; &lt;/style&gt;&lt;/resources&gt; 重新运行程序，试试效果吧：嘿嘿，是不是方便多啦！ 添加OnClick监听熟悉ListView的人应该知道，ListView给我们提供了onItemClickListener之类的监听器，当我们点击item的时候，它会回调相关的方法，以便我们可以方便的处理item的点击事件。然而RecyclerView它丫的竟然没有对item提供任何相关的回调方法，太不负责任了！还能肿么办，只能我们自己去添加咯，谁叫人家是当大爷的命呢。 简单起见，我们可以在Adapter中为其添加,修改TestAdapter，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.wuminmiao.recycleviewtest;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;/** * Created by wmm on 2016/10/13. */public class TestAdapter extends RecyclerView.Adapter&lt;TestAdapter.MyViewHolder&gt; &#123; private Context mContext; protected List&lt;String&gt; mDataset; private LayoutInflater mInflater;// 提供接口 public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125;// 声明类型 private OnItemClickListener mOnItemClickListener;// 提供它的set方法，供activity设置回调 public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mOnItemClickListener = listener; &#125; //提供一个合适的构造方法 public TestAdapter(Context context, List&lt;String&gt; dataset) &#123; this.mContext = context; this.mDataset = dataset; mInflater = LayoutInflater.from (context); &#125; /** *将布局转换为View并传递给自定义的MyViewHolder * @param viewGroup * @param viewType * @return */ @Override public MyViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; View view = mInflater.inflate (R.layout.item, viewGroup, false); MyViewHolder viewHolder = new MyViewHolder (view); return viewHolder; &#125; /** * 建立起MyViewHolder中视图与数据的关联 * @param viewHolder * @param position */ @Override public void onBindViewHolder(final MyViewHolder viewHolder, final int position) &#123; viewHolder.mTextView.setText (mDataset.get (position)); setUpItemEvent (viewHolder); &#125; // 设置item的回调 protected void setUpItemEvent(final MyViewHolder viewHolder) &#123; if (mOnItemClickListener != null) &#123; viewHolder.itemView.setOnClickListener (new View.OnClickListener () &#123; @Override public void onClick(View v) &#123; int layoutPosition = viewHolder.getLayoutPosition (); mOnItemClickListener.onItemClick (viewHolder.itemView, layoutPosition); &#125; &#125;); viewHolder.itemView.setOnLongClickListener (new View.OnLongClickListener () &#123; @Override public boolean onLongClick(View v) &#123; int layoutPosition = viewHolder.getLayoutPosition (); mOnItemClickListener.onItemLongClick (viewHolder.itemView, layoutPosition); return false; &#125; &#125;); &#125; &#125; /** * 获取item的数目 * @return */ @Override public int getItemCount() &#123; return mDataset.size (); &#125; public void addData(int position) &#123; mDataset.add (position, "Insert one"); notifyItemInserted (position); &#125; public void removeData(int position) &#123; mDataset.remove (position); notifyItemRemoved (position); &#125; //自定义的ViewHoder，持有item的所有控件 public static class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView mTextView; public MyViewHolder(View view) &#123; super (view); mTextView = (TextView) view.findViewById(R.id.text); &#125; &#125;&#125; 可以看到，我们给适配器提供了一个OnItemClickListener的接口，里面封装了两个回调方法分别是onItemClick(点击)和onItemLongClick(长按)。接着提供setOnItemClickListener方法让activity可以去监听它的回调方法。最后在onBindViewHolder中设置这两个回调方法。 这样就可以在activity中去监听这两个回调方法啦，我们在onCreate方法中添加如下代码：123456789101112mAdapter.setOnItemClickListener (new TestAdapter.OnItemClickListener () &#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText (MainActivity.this, "你点击了第" + position + "个item" , Toast.LENGTH_SHORT).show (); &#125; @Override public void onItemLongClick(View view, int position) &#123; mAdapter.removeData (position); &#125; &#125;); 代码很简单，当我们点击一个item时，会弹出一个Toast，而当我们长按一个item则会删除该item。 别忘了，我们的瀑布流布局与其他布局是不同的activity和adapter，我们还需要修改它们的代码。StaggeredGridActivity中和MainActivity需要添加的代码是一样的，而StagggeredAdapter也可以继承我们的TestAdapter，保留其特有的属性和方法就行了，StagggeredAdapter修改后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142package com.wuminmiao.recycleviewtest;import android.content.Context;import android.view.ViewGroup;import java.util.ArrayList;import java.util.List;/** * Created by wmm on 2016/10/13. */public class StagggeredAdapter extends TestAdapter&#123; private List&lt;Integer&gt; mHeight; //提供一个合适的构造方法 public StagggeredAdapter(Context context, List&lt;String&gt; dataset) &#123; super(context, dataset); mHeight = new ArrayList&lt;Integer&gt; (); for (int i = 0; i &lt; mDataset.size (); i++) &#123; mHeight.add ((int) (100 + Math.random ()*300)); &#125; &#125; /** * 建立起MyViewHolder中视图与数据的关联 * @param viewHolder * @param position */ @Override public void onBindViewHolder (MyViewHolder viewHolder, int position) &#123; viewHolder.mTextView.setText(mDataset.get (position)); ViewGroup.LayoutParams lp = viewHolder.itemView.getLayoutParams (); lp.height = mHeight.get (position); viewHolder.itemView.setLayoutParams (lp); setUpItemEvent (viewHolder); &#125;&#125; 还有一点要注意的是，如果现在运行程序的话，当我们点击item时它的颜色是不会变化的，这样的用户体验肯定很差，我们需要给它优化一下。 首先，在drawable中新建一个xml文件，就叫做bg_item吧：12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@color/state_item_pressed" android:state_pressed="true"&gt;&lt;/item&gt; &lt;item android:drawable="@color/state_item_normal"&gt;&lt;/item&gt;&lt;/selector&gt; 接着在values/colors.xml中指定其颜色：12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;color name="colorPrimary"&gt;#3F51B5&lt;/color&gt; &lt;color name="colorPrimaryDark"&gt;#303F9F&lt;/color&gt; &lt;color name="colorAccent"&gt;#FF4081&lt;/color&gt; &lt;color name="state_item_pressed"&gt;#728cd4&lt;/color&gt; &lt;color name="state_item_normal"&gt;#add8e6&lt;/color&gt;&lt;/resources&gt; 我们给默认的item和点击后的item设置了不同的颜色，这样体验效果应该会好一点。 现在，就可以运行我们的程序啦，效果如下： 总结在本文中，我们首先给RecyclerView实现了item添加和删除的动画效果，除了系统默认的效果，我们也可以自定义一些更加炫酷的动画效果。当然，得益于伟大的开源世界，我们可以直接在前人种的树下乘凉，比如这里,或者这里。 接着我们又给RecylerView的item添加了OnClick监听，我们可以根据需求处理各式各样的点击事件。 那么到这里，我们的Android RecyclerView的使用解析系列就完结啦。虽然这个系列讲解得非常基础，但由于个人水平有限，仍然可能会出现一些错误，欢迎大家指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android RecyclerView的使用解析（二）]]></title>
      <url>%2F2016%2F10%2F16%2Fandroid_recycle_view_test_02%2F</url>
      <content type="text"><![CDATA[定制分隔线在上一篇文章的学习中，我们对RecyclerView实现了一个ListView的效果，并给它设置了分割线，但是需要注意的是，这个分割线是默认的。当我们需要指定分割线的样式时，就需要来定制它了，那么怎样才能定制一个分割线样式呢？ 首先，我们要知道默认的分割线资源是在哪里获取的。通过DividerItemDecoration的源码，我发现它是通过获取系统Theme中的listDivider属性来实现自己的，那么如果我们要定制分割线，只需对这个属性进行修改即可。下面我们来定制一个颜色渐变效果的分割线。在drawable文件夹中新建一个文件，就叫做my_divider吧：123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle"&gt; &lt;size android:height="5dp"/&gt; &lt;gradient android:startColor="#00904a" android:centerColor="#ec3e01" android:endColor="#0089ff" android:type="linear"/&gt;&lt;/shape&gt; 接着我们修改values文件夹下的style.xml，将listDivder指定为我们刚刚创建的drawable：1234567&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="android:Theme.Holo.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="android:listDivider"&gt;@drawable/my_divider&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 重新运行程序，效果如下：当然，你也可以根据自己的需求定制不同的分隔线样式。 变变变，变身GridView大家或许已经察觉到利用RecyclerView来实现ListView的功能要比传统的ListView要来得复杂。这时你可能会有疑问了，既然它这么复杂你干嘛还要用它呢，你不是闲得蛋疼吗？别急嘛，且听我慢慢道来，还记得前面提到过的LayoutManager吗？你可别小瞧它哦，我们可以利用它快速得转换布局样式。 首先我们设置一个菜单以便切换布局样式,在Mainactivity中复写onCreateOptionsMenu和onOptionsItemSelected方法，并在res/meun中新建一个meun：12345678910111213141516171819&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" tools:context="com.wuminmiao.recycleviewtest.MainActivity" &gt; &lt;item android:id="@+id/action_listView" android:title="ListView" android:orderInCategory="100" app:showAsAction="never" /&gt; &lt;item android:id="@+id/action_gridView" android:title="GridView" android:orderInCategory="100" app:showAsAction="never" /&gt; &lt;item android:id="@+id/action_sta_gridView" android:title="@string/action_sta_gridView" android:orderInCategory="100" app:showAsAction="never" /&gt;&lt;/menu&gt; 接着修改MainActivity中onOptionsItemSelected的代码：12345678910111213141516171819@Override public boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); switch (id) &#123; case R.id.action_listView: mRecyclerView.setLayoutManager (new LinearLayoutManager (this)); break; case R.id.action_gridView: mRecyclerView.setLayoutManager (new GridLayoutManager (this, 3)); break; case R.id.action_sta_gridView: break; &#125; return super.onOptionsItemSelected(item); &#125; 重新运行程序，效果如下： 可以看到我们GridView的效果顺利实现了呢，我们只需改变一行代码就可以从ListView快速得切换到GridView，是不是很方便呢？ 不过大家可能也注意到了，GridView的分隔线只有水平方向有，而垂直方向却没有。这是因为我们定制的divider只绘制了item水平方向的分隔线，并没有绘制垂直方向的分隔线。为了更清晰的显示GridView，我们把MainActivity中设置分隔线的代码给注释掉：12//mRecyclerView.addItemDecoration (new DividerItemDecoration (this,// DividerItemDecoration.VERTICAL_LIST)); 然后给item的布局文件设置一个margin:123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:background="#add8e6" android:layout_margin="1dp" android:layout_height="70dp"&gt; &lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"/&gt;&lt;/FrameLayout&gt; 现在GridView的效果就完整的显示出来了： 实现瀑布流效果如果看了上面的效果你还是对RecyclerView不是很满意的话，那么接下来我相信它定会让你心服口服。首先，为了不妨碍我们当前activity的显示效果，我们新建一个activity来显示瀑布流的效果，新建StaggeredGridLayoutActivity，这里我们只需对原有的MainActivity代码略微修改即可：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import android.app.Activity;import android.os.Bundle;import android.support.v7.widget.RecyclerView;import android.support.v7.widget.StaggeredGridLayoutManager;import android.view.Menu;import android.view.MenuItem;import java.util.ArrayList;import java.util.List;public class StaggeredGridActivity extends Activity &#123; private RecyclerView mRecyclerView; private RecyclerView.Adapter mAdapter; private RecyclerView.LayoutManager mLayoutManager; private List&lt;String&gt; mDataset; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate (savedInstanceState); setContentView (R.layout.activity_main); initViews(); initData(); mLayoutManager = new StaggeredGridLayoutManager (3, StaggeredGridLayoutManager，.VERTICAL);//将LayoutManger设为StaggeredGridLayoutManager，也就是瀑布流布局 mRecyclerView.setLayoutManager (mLayoutManager);//设置布局管理器 mAdapter = new StagggeredAdapter (this, mDataset);//将适配器设为等下新建的StagggeredAdapter mRecyclerView.setAdapter (mAdapter);//设置适配器// mRecyclerView.addItemDecoration (new DividerItemDecoration (this,// DividerItemDecoration.VERTICAL_LIST)); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.menu_main, menu); return super.onCreateOptionsMenu(menu); &#125; private void initViews() &#123; mRecyclerView = (RecyclerView) findViewById (R.id.test_recycle_view); &#125; private void initData() &#123; mDataset = new ArrayList&lt;String&gt; (); for ( int i = 0; i &lt;= 50; i++) &#123; mDataset.add( "item"+i); &#125; &#125;&#125; 可以看到，这里我们只需把LayoutManger设置为StagggeredgridLayoutManager，并把adapter指定为即将创建的StagggeredAdapter，最后把不必要的onOptionsItemSelected方法删除即可。 那么，接下来我们来创建StagggeredAdapter，同样，我们只需在之前TestAdapter代码的基础上略作修改便可，StagggeredAdapter代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.ArrayList;import java.util.List;/** * Created by wuminmiao on 2016/10/13. */public class StagggeredAdapter extends RecyclerView.Adapter&lt;StagggeredAdapter.MyViewHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mDataset; private LayoutInflater mInflater; private List&lt;Integer&gt; mHeight; //提供一个合适的构造方法 public StagggeredAdapter(Context context, List&lt;String&gt; dataset) &#123; this.mContext = context; this.mDataset = dataset; mInflater = LayoutInflater.from (context); mHeight = new ArrayList&lt;Integer&gt; (); for (int i = 0; i &lt; mDataset.size (); i++) &#123; mHeight.add ((int) (100 + Math.random ()*300)); &#125; &#125; /** *创建ViewHolder * @param viewGroup * @param viewType * @return */ @Override public MyViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; View view = mInflater.inflate (R.layout.item, viewGroup, false); MyViewHolder viewHolder = new MyViewHolder (view); return viewHolder; &#125; /** * 建立起MyViewHolder中视图与数据的关联 * @param viewHolder * @param position */ @Override public void onBindViewHolder(MyViewHolder viewHolder, int position) &#123; viewHolder.mTextView.setText(mDataset.get (position)); ViewGroup.LayoutParams lp = viewHolder.itemView.getLayoutParams (); lp.height = mHeight.get (position); viewHolder.itemView.setLayoutParams (lp); &#125; /** * 获取item的数目 * @return */ @Override public int getItemCount() &#123; return mDataset.size (); &#125; //自定义的ViewHoder，持有item的所有控件 public static class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView mTextView; public MyViewHolder(View view) &#123; super (view); mTextView = (TextView) view.findViewById(R.id.text); &#125; &#125;&#125; 在这段代码中，我们主要想实现的是给每个item设置一个随机的高度。 首先定义一个成员变量mHeight，然后在构造方法中对它初始化，利用Math.random方法让它产生一些随机数。接着在onBindViewHolder方法中把刚刚得到的mHeight数据绑定到布局参数中并交由viewHolder处理，以实现设置item高度的目的。 最后在MainActivity中菜单的item中利用Intent打开StaggeredGridLayoutActivity：1234case R.id.action_sta_gridView: Intent intent = new Intent (this, StaggeredGridActivity.class); startActivity (intent); break; 最后的最后，别忘了，在manifest中对StaggeredGridLayoutActivity进行注册。 来看看成果吧： Bingo，我们顺利地实现了瀑布流的效果，是不是很简单啊！ 小结OK，我们来回顾一下本文的主要内容。首先，我们对RecyclerView的自定义分割线进行了讲解，在这里，我们巧妙的运用了系统的listDivider资源来实现分隔线的定制。以后的学习中，我们亦要延续这样的思维方式，以达到化繁为简的目的。接着，我们快速实现了RecyclerView的布局转换，这也是RecyclerView一大特色，我们可以方便地实现网格效果和瀑布流效果，这是ListView所不具备的。 在下篇文章中，我将对RecylerView添加动画效果和点击事件进行详解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android RecyclerView的使用解析（一）]]></title>
      <url>%2F2016%2F10%2F13%2Fandroid_recycle_view_test_01%2F</url>
      <content type="text"><![CDATA[前言RecyclerView是Android5.0带来的一个旨在替代ListView的新控件，收录在android.support.v7.widget包下。转眼之间，它已经面世2年了，大家也或多或少了解或运用过这个吊吊的控件，下面就由我带领您走向RecyclerView的世界。 初识RecyclerView我们先来看看这个控件的名字，所谓RecyclerView，意思就是老子只负责回收复用View，其它的事不管。看它趾高气扬的样子，你是不是想弄死它？其实啊，人家确实有装B的资格，相比较ListView而言，我们可以更加灵活地定制控件的效果。要使用RecyclerView，首先需要了解以下两个相关的类： LayoutManager 这个类主要用于控制RecyclerView的显示规则的，它是一个抽象类，系统给我们提供了三个默认的实现类，它们是LinearLayoutManager 、 GridLayoutManager和StaggeredGridLayoutManager。从名字就可以看出，我们可以利用它们分别让RecyclerView显示线性布局，网格布局和瀑布流布局。 RecyclerView.Adapter 同ListView一样，RecyclerView也提供一个适配器来控制每个item的显示内容。我们需要继承RecyclerView.Adapter&lt;VH extends VeiwHolder&gt;，并将泛型中的类名指定为自定义的ViewHolder类名，接着创建一个静态的自定义ViewHolder（RecyclerView帮我们封装好了ViewHolder，我们只需要在它的基础上实现功能即可），然后复写以下三个方法： onCreateViewHolder该方法主要为每一个item加载布局，并将布局传递给自定义的ViewHolder。 onBindViewHolder该方法主要是建立起自定义ViewHolder中视图与数据的关联。 getItemCount该方法用于对item进行计数。 简单的实现废话不多说，下面我们来进入实战，首先我们要实现一个ListView显示item项的效果。 在AS中新建一个项目，我们这里就叫做RecyclerViewTest吧，添加以下依赖： 1234dependencies &#123; ...//其它依赖 compile 'com.android.support:recyclerview-v7:24.2.1'&#125; 接着在布局文件中创建我们的RecyclerView布局：123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.wuminmiao.recycleviewtest.MainActivity"&gt; &lt;android.support.v7.widget.RecyclerView android:layout_width="match_parent" android:layout_height="match_parent" android:scrollbars="vertical"/&gt;&lt;/RelativeLayout&gt; 并创建item的布局：123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:background="#add8e6" android:layout_height="70dp"&gt;&lt;TextView android:id="@+id/text" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center"/&gt;&lt;/FrameLayout&gt; 然后在MainActivity的onCreate方法中获取RecyclerView的实例，并且为它设置适配器Adapter和布局管理器LayoutManager。MainActivity的代码如下：1234567891011121314151617181920212223242526272829303132333435363738import android.app.Activity;import android.os.Bundle;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import java.util.ArrayList;import java.util.List;public class MainActivity extends Activity &#123; private RecyclerView mRecyclerView; private RecyclerView.Adapter mAdapter; private RecyclerView.LayoutManager mLayoutManager; private List&lt;String&gt; mDataset; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate (savedInstanceState); setContentView (R.layout.activity_main); initViews(); initData(); mLayoutManager = new LinearLayoutManager (this, LinearLayoutManager.VERTICAL, false);//这里我们使用默认的线性布局管理器,将其设为垂直显示 mRecyclerView.setLayoutManager (mLayoutManager);//设置布局管理器 mAdapter = new TestAdapter(this, mDataset);//实例化适配器 mRecyclerView.setAdapter (mAdapter);//设置适配器 &#125; private void initViews() &#123; mRecyclerView = (RecyclerView) findViewById (R.id.test_recycle_view); &#125; private void initData() &#123; mDataset = new ArrayList&lt;String&gt; (); for ( int i = 0; i &lt;= 50; i++) &#123; mDataset.add( "item"+i); &#125; &#125;&#125; 接着我们就要创建自定义Adapter了：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import java.util.List;/** * Created by wuminmiao on 2016/10/13. */public class TestAdapter extends RecyclerView.Adapter&lt;TestAdapter.MyViewHolder&gt; &#123; private Context mContext; private List&lt;String&gt; mDataset; private LayoutInflater mInflater; //提供一个合适的构造方法 public TestAdapter(Context context, List&lt;String&gt; dataset) &#123; this.mContext = context; this.mDataset = dataset; mInflater = LayoutInflater.from (context); &#125; /** *将布局转换为View并传递给自定义的MyViewHolder * @param viewGroup * @param viewType * @return */ @Override public MyViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; View view = mInflater.inflate (R.layout.item, viewGroup, false); MyViewHolder viewHolder = new MyViewHolder (view); return viewHolder; &#125; /** * 建立起MyViewHolder中视图与数据的关联 * @param viewHolder * @param position */ @Override public void onBindViewHolder(MyViewHolder viewHolder, int position) &#123; viewHolder.mTextView.setText(mDataset.get (position)); &#125; /** * 获取item的数目 * @return */ @Override public int getItemCount() &#123; return mDataset.size (); &#125; //自定义的ViewHoder，持有item的所有控件 public static class MyViewHolder extends RecyclerView.ViewHolder &#123; TextView mTextView; public MyViewHolder(View view) &#123; super (view); mTextView = (TextView) view.findViewById(R.id.text); &#125; &#125;&#125; 现在，我们这个例子就可以正常运行了，效果如下：恩？好像哪里不对！分割线哪里去了？以前用ListView时，我们还可以通过divider属性来设置分割线，但到了RecyclerView这却不行了。这位大爷除了回收复用外啥事都不管，什么设置分割线啊，给item设置动画效果啊等等它丫的统统抛在脑后！那是不是就没辙了？肯定不是啦，前面我们就说过，我们可以自由地定制RecyclerView，那分割线这点芝麻大的事肯定也不在话下啦。 系统给我们提供了一个叫做ItemDecoration的抽象类，却并没有提供它的实现类供我们使用，所以我们必须通过自定义它去使用它，这里我就不重复造轮子啦，网上有很多现成的ItemDecoration的实现类，我们挑一个比较好用的来实现分割线效果:在我们的项目中添加DividerItemDecoration，该类的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import android.content.Context;import android.content.res.TypedArray;import android.graphics.Canvas;import android.graphics.Rect;import android.graphics.drawable.Drawable;import android.support.v7.widget.LinearLayoutManager;import android.support.v7.widget.RecyclerView;import android.view.View;public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException("invalid orientation"); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125; 现在我们只需要在MainActivity的onCreate方法中添加如下代码即可添加分隔线了：12mRecyclerView.addItemDecoration (new DividerItemDecoration (this, DividerItemDecoration.VERTICAL_LIST)); 运行程序，效果如下：由于原来的背景颜色太淡导致分隔线显示不明显，所以我换了一个背景色。 总结在这篇文章里，我们对RecyclerView有了一个基本的认识并实现了它的一个简单用法，在接下来的几篇博文里，我将给您带来RecyclerView的更多用法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java复习笔记之对象导论（一）]]></title>
      <url>%2F2016%2F10%2F09%2Fjava_notes_01%2F</url>
      <content type="text"><![CDATA[前言在android的学习过程中，我时常感到自己的Java基础掌握的不够牢靠，极大地拉低了android开发的效率，所以我准备花费一段时间系统地复习一下Java。这次复习的参考书籍是大名鼎鼎的《Java编程思想》。 抽象过程所有的编程语言都有抽象机制，那么到底什么是抽象呢，维基百科上的解释是这样的： 抽象就是把一个问题或模型，以不同规则或方法所得出的不同的解（求解方法和解本身即抽象层），这些不同的解可以组合并还原成问题或模型的本身。 人们所解决问题的复杂度取决于该问题的抽象的类型和质量，所谓的类型是指“所抽象的是什么”。比如汇编语言是对计算机底层的轻微抽象；C等“命令式“语言则是针对汇编语言进行抽象，这些语言虽然在汇编语言的基础上有了很大的改进，但是本质上它们所作的主要抽象仍要求在解决问题时要基于计算机的结构，而不是基于所要解决问题的结构去考虑。 程序员要做的是让机器模型（位于”解空间“内，即问题建模的地方，比如我们的计算机）和实际待解决问题的模型（位于”问题空间内“，即问题存在的地方，比如一些业务）建立起关联。而这个关联的过程就是编程。 编程方式众多，面向对象的方式便是其中之一。这种表示方式非常通用，它使我们不用受限于任何特定类型的问题。我们把问题空间中的元素以及其在解空间的表示称为“对象”。这种思想的实质是：程序可以通过添加新类型的对象使自身适用于每个特定问题。也就是说，我们在阅读解决问题的代码的同时也在阅读问题的描述。这种语言抽象相比较其他语言更加的灵活和强有力。所以OOP（面向对象程序设计）允许根据问题描述问题，而不是以往的根据允许解决方案的计算机来解决。每个对象就像是一个微型计算机，它既有状态，又有操作，用户可以要求对象执行这些操作。拿现实世界的对象作类比的话，那么说它们都具有特性和行为似乎不错。 面象对象语言的五个基本特性 万物皆为对象对象可以视为一个奇特的变量，他可以存储数据，也可以要求它对自身执行操作。理论上讲，我们可以抽取待解决问题的任何概念化构件（人、狗、建筑物、服务等）将其表示为程序里的对象。 程序是对象的集合，它们可以通过发送消息来告知彼此所要做的要想请求一个对象，就必须对该对象发送一条消息，更具体点说，可以把消息想象为对某个特定对象的调用请求。 每个对象都有自己的由其他对象所构成的存储换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构件复杂的体系，同时将其复杂性隐藏在对象的简单性背后。 每个对象都拥有其类型按照通用的说法，“每个对象都是某个类(class)的一个实例(instance)”，这里的”类“就是”类型“的同义词。每个类最重要的区别于其他类的特性就是”可以发送什么样的消息给它“。 某个特定类型的所有对象都可以接受同样的消息比如一个”圆形“类型的对象同时也是”几何形“类型的对象，所以一个”圆形“对象必定能够接受发送给”几何形“对象的消息。这种可替代性(substitutability)是OOP中最强有力的概念之一。总结：对象具有状态、行为和标识。这意味着每一个对象都可以拥有内部数据（它们给出了对象的状态）和方法（它们产生行为），而且每一个对象都可以唯一地与其他对象区分开来（比如我们可以区分人与人之间的不同）。 每个对象都有一个接口亚里士多德可能是第一个深入研究类型(type)的哲学家，他曾提出鱼类和鸟类这样的概念。所有的对象都是唯一的，但同时是具有相同特性和行为的对象所归属的类的一部分。 创建抽象数据类型（类）是OOP的基本概念之一。抽象数据类型的运行方式和内置(built-in)类型几乎完全一致：你可以创建某一类型的对象（或者叫做实例），然后操作这些对象（发送消息或请求；发送消息，对象就知道要做什么）。 每个类的成员或元素都具有某种共性（比如每个人都有名字，每只狗都会“汪汪”叫），同时每个成员都有其自身的状态（比如他叫张三，我叫李四；这只狗叫旺财，那只狗叫小黑）。因此诸如人和狗等都可以在计算机程序中被表示为唯一的实体。这些实体就是对象，每个对象都属于定义了特性和行为的每个特定的类。 所以，尽管我们在OOP中实际上进行的是创建新的数据类型，但事实上所有的OOP语言都是用class这个关键字来表示数据类型。当看到类型一词时，可将其作为类来考虑，反之亦然。 因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序员可以通过定义类来适应问题，而不再被迫使用现有的用来表示机器中的存储单元的数据类型，可以根据需求，通过增加新的数据类型来扩展编程语言，而编程系统欣然接受新的类，并且像对待内置类型一样地照管它们和进行类型检查。 如何才能获得有用的对象呢？必须有某种方式产生对对象的请求，使对象完成各种任务，如完成一笔交易，打开一个开关，在屏幕上画图等等。每个对象都只能满足某些请求，这些请求由对象的接口(interface)定义，决定接口的便是类型。 接口确定了对某一特定对象所能发出的请求。但是，在程序中必须有满足这些请求的代码，这些代码与隐藏的数据一起构成了实现。在类型中，每一个可能的请求都有一个方法与之相关联，当对象发送请求时，与之相关联的方法就会被调用。此过程通常被概括为：向某个对象“发送消息”（产生请求），这个对象便知道此消息的目的，然后执行对应的程序代码。以电灯泡为例做一个简单的比喻（下图所示）：12Light lt = new Light();lt.on(); 上例中，类型/类的名称是Light，特定的Light对象的名称是lt，可以向Light对象发出的请求是：打开它、关闭它、将它调亮、将它调暗。以下列方式创建了一个Light对象：定义一个对象的“引用”(lt),然后调用new方法来创建该类型的新对象。为了向对象发送消息，需要声明对象的名称，并以英文句号连接一个消息请求。从预定义类的用户观点来看，这些差不多就是用对象进行设计的全部。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我的博客上线了]]></title>
      <url>%2F2016%2F10%2F01%2Fmy_blog%2F</url>
      <content type="text"><![CDATA[博客结构 基于:Github Pages &amp; Coding Pages 框架:Hexo 主题:nexT 构建目的 记录&amp;沉淀 交流学习 便于管理]]></content>
    </entry>

    
  
  
</search>
